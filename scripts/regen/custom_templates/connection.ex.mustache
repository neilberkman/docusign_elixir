{{>licenseInfo}}
defmodule {{moduleName}}.Connection do
  @moduledoc """
  Handle Req connections for {{moduleName}}.

  The default base URL can be set as:

      config {{#atom}}{{#underscored}}{{packageName}}{{/underscored}}{{/atom}},
        :base_url, "{{{basePath}}}"
  """

  @default_base_url Application.compile_env(
                      {{#atom}}{{#underscored}}{{packageName}}{{/underscored}}{{/atom}},
                      :base_url,
                      "{{{basePath}}}"
                    )

  {{#hasOAuthMethods}}
  @type token_fetcher :: (list(String.t()) -> String.t())

  @default_scopes [{{#scopes}}"{{scope}}"{{^-last}}, {{/-last}}{{/scopes}}]
  {{/hasOAuthMethods}}

  @type options :: [
          {:base_url, String.t()},
          {:user_agent, String.t()},
  {{#hasOAuthMethods}}
          {:token, String.t() | token_fetcher | {module :: atom(), function :: atom()}},
          {:token_scopes, list(String.t())},
  {{/hasOAuthMethods}}
  {{#hasApiKeyMethods}}
          {:api_key, String.t()},
  {{/hasApiKeyMethods}}
  {{#hasHttpBasicMethods}}
          {:username, String.t() | nil},
          {:password, String.t() | nil},
  {{/hasHttpBasicMethods}}
  {{#hasHttpBearerMethods}}
          {:bearer_token, String.t() | nil},
  {{/hasHttpBearerMethods}}
        ]

  @doc "Forward requests to Req."
  @spec request(Req.Request.t(), keyword()) :: {:ok, Req.Response.t()} | {:error, any()}
  def request(req, options) do
    Req.request(req, options)
  end

  @doc """
  Configure a {{moduleName}} client.

  ### Parameters

  - `options`: an optional keyword list of {{moduleName}}.Connection.options.

  ### Returns

  Req.Request.t()
  """
  @spec new(options) :: Req.Request.t()
  def new(options \\ []) do
    base_url =
      Keyword.get(
        options,
        :base_url,
        Application.get_env({{#atom}}{{#underscored}}{{packageName}}{{/underscored}}{{/atom}}, :base_url, @default_base_url)
      )

    user_agent =
      Keyword.get(
        options,
        :user_agent,
        "openapi-generator - {{moduleName}} {{packageVersion}} - elixir"
      )

    headers = [{"user-agent", user_agent}]

    {{#hasHttpBasicMethods}}
    username = Keyword.get(options, :username)
    password = Keyword.get(options, :password)
    auth = if username || password do
      {:basic, "#{username}:#{password}"}
    else
      nil
    end
    {{/hasHttpBasicMethods}}

    {{#hasHttpBearerMethods}}
    bearer_token = Keyword.get(options, :bearer_token)
    headers = if bearer_token do
      [{"authorization", "Bearer #{bearer_token}"} | headers]
    else
      headers
    end
    {{/hasHttpBearerMethods}}

    {{#hasOAuthMethods}}
    headers =
      if token = Keyword.get(options, :token) do
        scopes = Keyword.get(options, :token_scopes, @default_scopes)
        token_value = resolve_token(token, scopes)
        [{"authorization", token_value} | headers]
      else
        headers
      end
    {{/hasOAuthMethods}}

    req_options = [
      base_url: base_url,
      headers: headers
    ]

    {{#hasHttpBasicMethods}}
    req_options = if auth do
      Keyword.put(req_options, :auth, auth)
    else
      req_options
    end
    {{/hasHttpBasicMethods}}

    Req.new(req_options)
  end

  {{#hasOAuthMethods}}
  defp resolve_token(token, _scopes) when is_binary(token) do
    token
  end

  defp resolve_token({module, function}, scopes) when is_atom(module) and is_atom(function) do
    apply(module, function, [scopes])
  end

  defp resolve_token(token_fetcher, scopes) when is_function(token_fetcher, 1) do
    token_fetcher.(scopes)
  end
  {{/hasOAuthMethods}}
end
